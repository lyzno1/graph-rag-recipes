# GraphRAG 菜谱实现细节报告

## 1. 仓库概览
- **语言与运行时**：Python 3.11，使用 `uv` 管理依赖与锁文件（`pyproject.toml` + `uv.lock`）。
- **核心目录**：
  - `src/graph_rag_recipes/`：全部业务逻辑模块。
  - `scripts/`：`bootstrap_data.py`（数据准备）与 `run_pipeline.py`（CLI Demo）。
  - `data/raw`、`data/processed`：分别存放 HowToCook 原始仓库与解析后的 JSON。
  - `docs/`：团队演示用的技术/实现报告（本文件）。
- **运行命令**：`uv sync` → `uv run scripts/bootstrap_data.py` → `uv run scripts/run_pipeline.py U123`。

## 2. 核心模块拆解（按调用顺序）
| 序号 | 文件 | 主要类/方法 | 实现要点 |
| --- | --- | --- | --- |
| 1 | `config.py` | `ProjectConfig` | 负责路径、模型、阈值的集中配置，并通过 `dotenv` 自动加载 `.env`。 |
| 2 | `data_ingest.py` | `HowToCookIngestor` | 下载/解析 HowToCook Markdown，迭代生成 `RecipeRecord`；支持示例数据兜底。 |
| 3 | `graph_builder.py` | `RecipeGraphBuilder` | 对任意两菜谱计算相似度（食材 Jaccard / 覆盖度 / 标签 Jaccard 加权），构建 networkx 图。 |
| 4 | `embeddings.py` | `RecipeEmbeddingIndex` | 调用 `sentence-transformers` 构造语义索引，支持文本/菜谱向量检索；依赖缺失时自动降级。 |
| 5 | `retrieval.py` | `RecipeRetriever` | 基于图邻域排序获取相似菜谱，提供标题模糊匹配。 |
| 6 | `user_profiles.py` | `UserProfileRepository` | 提供内置用户画像（`U123/U207/U305`）及对应历史菜谱 ID。 |
| 7 | `llm_generator.py` | `LLMGenerator` | 构造 prompt 调用 OpenAI Responses API，或输出模板理由。 |
| 8 | `pipeline.py` | `GraphRAGPipeline` | 串联上述模块，提供 `bootstrap_graph()`、`recommend()`、`run_demo()`；核心入口。 |
| 9 | `ui_components.py` | `format_cli_block` | 统一 CLI 输出格式，方便 PPT 直接截图。 |

## 3. 主流程伪代码
```python
config = ProjectConfig()
pipeline = GraphRAGPipeline(config)

# Step 1 构建图
pipeline.bootstrap_graph()

# Step 2 接收输入
result = pipeline.recommend(user_query)  # user_query: "U123" / "番茄炒蛋"

# Step 3 输出展示
print(format_cli_block(result))
```
- `recommend()` 内部逻辑：
  1. 判断输入是否匹配用户画像 → `user_profile = repository.get(query)`。
  2. 若命中，遍历 `liked_recipe_ids` 获取邻居并合并候选；否则进入文本检索。
  3. `_find_reference_recipe()` 一次尝试节点 ID → 标题模糊 → 向量 Top-1。
  4. 依次尝试图邻居、向量近邻、示例 fallback；确保返回非空候选。
  5. `LLMGenerator.generate()` 根据参考菜谱 + 候选 + 用户输入构造 prompt 并生成解释。

## 4. 数据准备实现细节
- `HowToCookIngestor.prepare_local_copy()`：
  - 默认策略 `auto`：先尝试 `git clone --depth 1`，失败时转为下载压缩包。
  - 每次运行会执行 `paths.ensure()`，自动创建 `data/raw`、`data/processed`。
  - 拉取失败时创建 `DATASET_PLACEHOLDER.txt` 并提示手动放置仓库。
- `build_processed_dataset()`：
  - 遍历目录下的 `.md` 文件，剔除 `docs/`、`template/`、`.github/` 等噪声。
  1. `_extract_sections()` 根据 ##/### 标题匹配中文别名，抽取食材/调料/步骤。
  2. `_parse_markdown_file()` 合并主食材+调料为 `ingredients`，提取路径标签。
  3. 将 `RecipeRecord` 序列化写入 `data/processed/recipes_index.json`。
  - `load_sample_records()` 首次调用会写入 `sample_recipes.json`（番茄家族示例）。

## 5. 图与检索实现
- **相似度计算**：
  - 食材 Jaccard（`0.6` 权重）：体现共有食材比例。
  - 食材覆盖率（`0.3`）：小菜谱 vs 大菜谱的最小集合重合程度。
  - 标签 Jaccard（`0.1`）：保留口味/菜系信息。
  - 仅当综合得分 ≥ `ProjectConfig.similarity_threshold` 才连边，降低噪声。
- **邻域推荐**：
  - `RecipeRetriever.find_similar_recipes()` 获取 `(neighbor, weight)` 列表，按权重降序取前 `max_neighbors`。
  - 用户画像场景中会聚合多个历史菜谱的邻居并去重，对热门节点能获得更多候选。
- **向量回退**：
  - `RecipeEmbeddingIndex.build()` 统一生成文本 embedding；缺少 sentence-transformers 时 `_enabled=False`，不会报错。
  - `_fallback_candidates()` 依据食材/标签重叠手动排序，确保结果可解释。

## 6. LLM 接入及 Prompt
- `LLMGenerator.build_prompt()` 模板：
  1. “你是一名善于解释口味风格的智能厨房助手。”（指令）
  2. `用户输入` 原样放入，保留语境。
  3. `参考菜谱` + `候选菜谱` 使用 `RecipeRecord.as_prompt_chunk()` 统一格式，含食材、标签、做法摘要。
  4. 结尾指示“请用中文生成推荐理由，突出共同食材或口味，并给出建议”。
- API 调用：默认 `OpenAI(api_key)` → `responses.create(model=llm_model, input=prompt)`。
  - 若 `.env` 未配置 Key，则 `_client=None`，自动返回食材重叠模板解释，避免流程中断。
  - 支持通过修改 `ModelSettings.llm_provider` 切换到其他厂商（需扩展 `llm_api_key()` 的映射）。

## 7. 使用方式与参数速查
| 场景 | 命令/参数 | 说明 |
| --- | --- | --- |
| 安装依赖 | `uv sync` | 读取 `uv.lock` 创建隔离环境。 |
| 准备数据 | `uv run scripts/bootstrap_data.py --limit 800 --force-processed` | 下载 / 解析最新数据；可用 `--skip-download` 离线运行。 |
| CLI Demo | `uv run scripts/run_pipeline.py U123` | 输入用户 ID，走“画像路径”；直接输入菜名则走文本路径。 |
| 包入口 | `uv run graph-rag-recipes "番茄炒蛋"` | 调用 `src/graph_rag_recipes/__init__.py` 中的 `main()`。 |
| 测试 | `uv run pytest -q` | 未来补充测试用例时的统一命令。 |

## 8. 自定义与扩展建议
1. **新增用户画像**：在 `user_profiles.py` 中追加 `UserProfile`，并确保 `liked_recipe_ids` 与 processed 数据一致，即可在 CLI 输入新的用户 ID。
2. **扩展配置**：在 `config.ProjectConfig` 增加字段，例如 `llm_temperature`、`graph_cache_path`，并同步在 `.env.example` 和 `README` 中说明。
3. **外部 UI**：可在 Streamlit 中导入 `GraphRAGPipeline`，调用 `recommend()` 后使用 `ui_components.streamlit_render()` 渲染。
4. **评估指标**：可在 `RecommendationResult` 中新增 `metadata` 字段，用于记录相似度、重叠食材等，便于 PPT 展示“算法依据”。
5. **性能优化**：若数据量扩大，可在 `RecipeGraphBuilder.build_graph()` 中加入分桶（按菜系/主食材）或使用局部倒排来减少 O(N²) 组合。

## 9. 常见问题排查
| 问题 | 定位方式 | 解决方案 |
| --- | --- | --- |
| `requests` 报错 / 下载失败 | 查看 `data/raw/DATASET_PLACEHOLDER.txt` 是否存在 | 使用 `--skip-download` 先跑示例；或手动 clone 仓库至 `data/raw/howtocook_repo`。 |
| CLI 输出没有推荐理由 | 检查 `.env` 中是否配置 `OPENAI_API_KEY` | 未配置时为模板文案，若需要真实 LLM 效果需填入 Key。 |
| `sentence-transformers` 下载缓慢 | 首次 `uv sync` 只装依赖，模型会在运行时下载 | 可预先下载并设置 `HF_HOME`，或在 `ModelSettings.embedding_model` 指向本地文件夹。 |
| `networkx` 导致构图耗时 | 主要取决于菜谱数量 | 通过 `--limit` 控制解析数量，或调高 `similarity_threshold` 降低连边数量。 |

## 10. PPT 复用建议
- **结构页**：引用第 2 节表格，概括每个模块的职责。
- **流程页**：使用第 3 节伪代码 + 文字描述讲解 GraphRAG 推荐链路。
- **数据页**：展示第 4 节解析亮点，加上 `data/processed/sample_recipes.json` 的截屏。
- **算法页**：突出第 5 节相似度公式和邻域/向量回退策略。
- **效果页**：运行 CLI Demo 截图，并将输出贴到 PPT 中展示“参考菜谱 + 相似菜谱 + 推荐理由”。

> 该实现报告可在组会/答辩中结合技术方案报告一起使用：技术方案负责宏观叙事，实施报告负责落地细节和操作指引。
